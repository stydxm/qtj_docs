# 基础概念

## 镜像

容器镜像可以类比装系统时的系统镜像，包含了运行某个应用程序所需的所有内容

镜像本身是只读的，不能被修改，使用时会在镜像基础之上更改一些内容，并不会保存到原来的镜像中（当然可以保存为一个新镜像）

可以使用images命令列出本地所有镜像

```bash
docker images
```

可以使用pull命令下载所需镜像

```bash
docker pull 镜像名
```

## 镜像的层

镜像采用分层的结构实现，每一层对应构建时的一条命令。这些层是只读的，按顺序叠加构成完整的镜像。

举个例子，假设你有一个 Dockerfile（如何写Dockerfile将在后面章节介绍）：

```dockerfile
FROM ubuntu
COPY . /app
RUN apt update && apt install -y python3
CMD ["python3", "/app/hello.py"]
```

Docker 构建这个镜像时会生成如下几层：
- `ubuntu` 的系统文件
- 将本地文件复制到 `/app` 目录；
- 安装 Python
- 设置启动命令

每层都被分开储存，每次构建时只会重新构建有变化的层及其之上的层，这大大提高了构建效率

需要下载、储存多个镜像时也是，相同的层在硬盘上只有一份，节省了空间、提高了下载速度

你可以使用以下命令查看Ubuntu这个镜像包含的层

```bash
docker image history ubuntu
```

输出会显示每一层的创建时间、大小以及对应的构建命令等信息

## 容器

可以把镜像看作类，容器是这个类实例化的一个对象，多个容器可以基于同一个镜像启动，分别存储，互不干扰 ~~记住，跑得快不一定赢，不跌跟头才是成功~~

当一个容器启动时，Docker 会在镜像的最上层添加一个可写的层，所有文件更改都发生在这个层中。容器被删除时这个层也会被销毁，但可以通过其他方式保存数据（比如用`docker commit`保存这个层生成一个新镜像，或者使用卷，或者将路径映射到容器外）

## 卷

虽然在容器内可以修改文件，但这些修改是临时的，容器被删除后就丢失了。为了实现数据持久化，Docker 提供了卷这个机制。你可以把每个卷想象成一个箱子，使用时把它们挂载到你想要的位置，且不需要考虑里面存放了什么。这些箱子里的东西可以随时读写，但与容器本身的数据分离，不会随容器一起创建或删除

卷不与任何一个容器绑定，可以同时被挂载到多个容器以实现数据共享，也可以在宿主机上直接访问，可以用于储存数据库数据、软件日志、配置文件等场景


## 仓库

仓库是用来存放镜像、提供下载的服务，最常用的也是Docker默认的公共仓库是 [Docker Hub](https://hub.docker.com)，许多大型企业或组织也会搭建自己的镜像仓库

由于我们到Docker Hub的网络连接通常不是很好，切换到其他位于国内服务器上的仓库可以大幅加速镜像下载
